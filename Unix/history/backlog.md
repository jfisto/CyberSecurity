В рамках работы были выполнены следующие задачи:
=====================================================
#### 1. *Исправление возникшей ошибки игнорирования нулевых байтов при чтении*
#### 2. *Реализайция получения индекса команды при работе с настроенным форматом времени*
#### 3. *Разработка и оптимизация проверки установленного формата времени при логировании команд в history*
#### 4. *Рефакторинг уже имеющегося кода и кода с учетом добавленных нововведений*

В рамках работы были выполнены следующие задачи:
-----------------------------------------------------------
### *Исправление возникшей ошибки игнорирования нулевых байтов при чтении*

if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(cat /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then

***Данная проблема возникает при использовании переменных среды и проверки соответствия содержимого файла /proc/$$/cmdline значению bash-c"/etc/forcecommand.sh"***

***Для решения этой проблемы можно использовать следующие решения:***
#### 1. if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(tr -d '\0' < /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then
*В команде используется tr -d '\0'. Параметр -d указывает на удаление символов, а '\0' - это символ, представляющий нулевой байт, который может использоваться в строках, созданных в некоторых операционных системах, таких как Linux. Поэтому tr -d '\0' удаляет все нулевые байты из строки, полученной из /proc/$$/cmdline.*
#### 2. if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(tr '\0' ' ' < /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then
*В данной команде, tr '\0' ' ' используется для замены нулевых байтов на пробелы в строке, полученной из /proc/$$/cmdline. Это может быть полезно для отображения строки в удобном для чтения формате, но не обязательно для проверки условия.*

![Исправление ошибки игнорирования нулевого байта](https://github.com/jfisto/CyberSecurity/edit/main/Unix/history/1.png)

### *Реализайция получения индекса команды при работе с настроенным форматом времени*

*Ниже представлен код отвечающий за обработку пользовательских команд и определение последенй введенной и предпоследней команд:*
  
`if [ -z "$AUDIT_LASTHISTLINE" ]; then
  local AUDIT_CMD="$(fc -l -1 -1)"
  AUDIT_LASTHISTLINE="${AUDIT_CMD%%+([^ 0-9])*}"
else
  AUDIT_LASTHISTLINE="$AUDIT_HISTLINE"
fi
  local AUDIT_CMD="$(history 1)"
  AUDIT_HISTLINE="${AUDIT_CMD%%+([^ 0-9])*}"`

*В данном коде в переменную AUDIT_CMD записывается последняя введенная пользователем команда. Отметим, что учитывая использование утилиты fc с параметрами -l -1 -1, то в переменную AUDIT_CMD записывается предпоследняя команда, в отличии от использования утилиты history 1, которая выводит последнюю команду (то есть саму себя "history 1").*\
*К сожалению я не нашел разумного описания использования утилиты fc для вывода последней команды с выводом времени (тк ключ -t работает не для всех Unix-подобных операционных систем)*\
*Таким образом, для выполнения данной подзадачи я решил не изобретать велосипед, а использовать уже известную утилиту history, которая при установленных настройках формата HISTTIMEFORMAT логирует команды в формате <index> <datetime> <command>.*\
*Добится этого позволяет изменение строки local AUDIT_CMD="$(fc -l -1 -1)" на local AUDIT_CMD="$(history 2 | head -n 1)", где выводится первая команда из последних двух.*
  
*Далее в переменную AUDIT_LASTHISTLINE записывается индекс команды, однако в случае если установлен формат с логированием времени, то в переменную записывается <index>  <datetime>, в результате чего значение переменной не является Integer и при проверки содержимого возникает ошибка.*\
*Данная ошибка фиксится изменением присваиваемого содержимого переменной на первое "слово" (индекс команды) в переменной AUDIT_CMD, которое можно реализавать следующим образом AUDIT_LASTHISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')*
  
*Таким образом, фрагмент кода должен выглядить следующим образом:*
if [ -z "$AUDIT_LASTHISTLINE" ]; then\
  \tlocal AUDIT_CMD="$(history 2 | head -n 1)"\
  \tAUDIT_LASTHISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')\
else\
  \tAUDIT_LASTHISTLINE="$AUDIT_HISTLINE"\
fi\
local AUDIT_CMD="$(history 1)"\
AUDIT_HISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')


![Исправление ошибки игнорирования нулевого байта](https://github.com/jfisto/CyberSecurity/edit/main/Unix/history/2.png)

### *Разработка и оптимизация проверки установленного формата времени при логировании команд в history*


![Исправление ошибки игнорирования нулевого байта](https://github.com/jfisto/CyberSecurity/edit/main/Unix/history/3.png)

### *Рефакторинг уже имеющегося кода и кода с учетом добавленных нововведений*


![Исправление ошибки игнорирования нулевого байта](https://github.com/jfisto/CyberSecurity/edit/main/Unix/history/4.png)


