В рамках работы были выполнены следующие задачи:
===
- [X] *Исправление возникшей ошибки игнорирования нулевых байтов при чтении*
- [X] *Реализайция получения индекса команды при работе с настроенным форматом времени*
- [X] *Разработка и оптимизация проверки установленного формата времени при логировании команд в history*
- [X] *Рефакторинг уже имеющегося кода и кода с учетом добавленных нововведений*
- [X] *Замечания*

### В рамках работы были выполнены следующие задачи:
### *Исправление ошибки игнорирования нулевых байтов при проверки условия*

```
if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(cat /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then
```

Данная проблема возникает при использовании переменных среды и проверки соответствия содержимого файла `/proc/$$/cmdline` значению `bash-c"/etc/forcecommand.sh"` и сопровождается предупреждением:
> ignored null byte in input

Для решения этой проблемы можно пойти двумя путями:
#### 1. Путем удаления всех нулевых байтов в строке
```
if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(tr -d '\0' < /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then
```
В команде используется `tr -d '\0'`. Параметр `-d` указывает на удаление символов, а `'\0'` - это символ, представляющий нулевой байт, который может использоваться в строках, созданных в некоторых операционных системах, таких как Linux. Поэтому `tr -d '\0'` удаляет все нулевые байты из строки, полученной из `/proc/$$/cmdline`.

#### 2. Путем замены всех нулевых байтов в строке на пробелы
```
if [ "$AUDIT_INCLUDED" == "$$" ] || { [ -z "$SSH_ORIGINAL_COMMAND" ] && [ "$(tr '\0' ' ' < /proc/$$/cmdline)" == 'bash-c"/etc/forcecommand.sh"' ]; }; then
```
В данной команде, `tr '\0' ' '` используется для замены нулевых байтов на пробелы в строке, полученной из `/proc/$$/cmdline`. Это может быть полезно для отображения строки в удобном для чтения формате, но не обязательно для проверки условия.

---
### *Реализайция получения индекса команды при работе с настроенным форматом времени*

Ниже представлен код отвечающий за обработку пользовательских команд и определение последенй введенной и предпоследней команд:
  
```
if [ -z "$AUDIT_LASTHISTLINE" ]; then
  local AUDIT_CMD="$(fc -l -1 -1)"
  AUDIT_LASTHISTLINE="${AUDIT_CMD%%+([^ 0-9])*}"
else
  AUDIT_LASTHISTLINE="$AUDIT_HISTLINE"
fi
  local AUDIT_CMD="$(history 1)"
  AUDIT_HISTLINE="${AUDIT_CMD%%+([^ 0-9])*}"
```

В данном коде в переменную AUDIT_CMD записывается последняя введенная пользователем команда. Отметим, что учитывая использование утилиты `fc` с параметрами `-l -1 -1`, то в переменную `AUDIT_CMD` записывается предпоследняя команда, в отличии от использования утилиты `history 1`, которая выводит последнюю команду (то есть саму себя `history 1`).
К сожалению я не нашел разумного описания использования утилиты `fc` для вывода последней команды с выводом времени (тк ключ `-t` работает не для всех Unix-подобных операционных систем).
Таким образом, для выполнения данной подзадачи я решил не изобретать велосипед, а использовать уже известную утилиту `history`, которая при установленных настройках формата `HISTTIMEFORMAT`
логирует команды в формате {index} {datetime} {command}.
  
Добится этого позволяет изменение строки `local AUDIT_CMD="$(fc -l -1 -1)"` на `local AUDIT_CMD="$(history 2 | head -n 1)"`, где выводится первая команда из последних двух.
  
Далее в переменную `AUDIT_LASTHISTLINE` записывается индекс команды, однако в случае, если установлен формат с логированием времени, то в переменную записывается {index} {datetime}, в результате чего значение переменной не является `Integer` и при проверки содержимого возникает ошибка:
> integer expression expected
  
Данная ошибка фиксится изменением присваиваемого содержимого переменной на первое "слово" (индекс команды), хранящееся в переменной `AUDIT_CMD`. Реализуется следующим образом `AUDIT_LASTHISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')`
  
Таким образом, фрагмент кода должен выглядить следующим образом:
```
if [ -z "$AUDIT_LASTHISTLINE" ]; then
  local AUDIT_CMD="$(history 2 | head -n 1)"
  AUDIT_LASTHISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')
else
  AUDIT_LASTHISTLINE="$AUDIT_HISTLINE"
fi
local AUDIT_CMD="$(history 1)"
AUDIT_HISTLINE=$(echo "$AUDIT_CMD" | awk '{print $1}')
```
___
### *Разработка и оптимизация проверки установленного формата времени при логировании команд в history*

Следующим этапом предстоит реализовать проверку дувух условий - проверку установленного формата времени в `history` (задается переменной среды `HITTIMEFORMAT`) и проверку самого формата временной метки, задаваемого для логирования команд.
  
Для того, чтобы обрабатывать полученные из history команды и успешно передавать их на запись в журнал syslog без использования временной метки, необходимо воспользоваться следующей конструкцией в своем конфиге ~/.bashrc:
```
if ! logger -p  local3.debug -t "$AUDIT_STR "[COMMAND="$PWD" "${AUDIT_CMD##*( )?(+([0-9])[^0-9])*( )}""]"; then
    echo "error $AUDIT_STR "[COMMAND="$PWD" "${AUDIT_CMD##*( )?(+([0-9])[^0-9])*( )}""]"
fi
```
Использование временной метки в `history` требует обработки форматов задаваемых в переменной среды `HISTTIMEFORMAT`, для чего предлагается использование регулярного выражения `^\s*\d{1,}\s*([0-9]{1,}. [a-zA-Z]{1,}.[0-9]{1,}|[a-zA-Z]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}.[a-zA-Z]{1,}|[0-9]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}|[0-9]{1,})\s+([0-9]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}|[0-9]{1,})\s+(.*)`, которое позволит учесть возмозжные числовые задаваемые форматы времени (<date> <time> или <time> <date>):

```
if echo "$AUDIT_CMD" | grep -Eq '^\s*\d{1,}\s*([0-9]{1,}. [a-zA-Z]{1,}.[0-9]{1,}|[a-zA-Z]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}.[a-zA-Z]{1,}|[0-9]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}|[0-9]{1,})\s+([0-9]{1,}.[0-9]{1,}.[0-9]{1,}|[0-9]{1,}.[0-9]{1,}|[0-9]{1,})\s+(.*)'; then
    AUDIT_CMD=$(echo "$AUDIT_CMD" | awk '{for(i=4;i<=NF;i++) printf "%s ",$i}')
    if ! logger -p  local3.debug -t "$AUDIT_STR "[COMMAND="$PWD" "$AUDIT_CMD]"; then
      echo "error $AUDIT_STR "[COMMAND="$PWD" "$AUDIT_CMD]"
    fi
else
    if ! logger -p  local3.debug -t "$AUDIT_STR "[COMMAND="$PWD" "${AUDIT_CMD##*( )?(+([0-9])[^0-9])*( )}""]"; then
      echo "error $AUDIT_STR "[COMMAND="$PWD" "${AUDIT_CMD##*( )?(+([0-9])[^0-9])*( )}""]"
    fi
fi
```
Таким образом, переменная `$AUDIT_CMD` проверяется на наличие в строке числовых форматов даты и времени (то есть {index} {datetime} {command}) и в случае удовлетворению регулярному выржению переходит в первое условие и приступает к парсингу команды.
Данная команда `AUDIT_CMD=$(echo "$AUDIT_CMD" | awk '{for(i=4;i<=NF;i++) printf "%s ",$i}')` извлекает часть строки с командой и ее аргументами, начиная с 4-го аргумента и сохраняет ее в переменной `$AUDIT_CMD`. Поскольку awk читает каждую строку входного потока и разбивает ее на поля, используя в качестве разделителя по умолчанию пробел, то в 1ом поле содержаться индекс команды, во 2ом и 3ем - дата и время применения команды, а 4ом и тд будет сама команда с ее аргументами, которапя поступит на запись в журнал syslog.

___
### *Рефакторинг уже имеющегося кода и кода с учетом добавленных нововведений*

В конфиге bashrc.audit
  
___
### *Замечания*
  
Для того, чтобы установить настройку переменных сред для всех пользователей необходимо в явном виде добавить запись о переменной среде в конфигурационный файл `/etc/profile`
Например:
`HISTTIMEFORMAT='%d/%m/%y %T'`
В если устанавливается настройка переменной среды в `~/.bashrc`, для Debian, то она работает только в рамках сессии суперпользователя, но не работает для остальных пользователей. Для того, чтобы задать переменные среды для остальных пользователей, нуобходимо добавить необъодимы значения переменных сред в коннннфигурационный файл `~/.bashrc` в домашнеих директориях соответствующих пользователей.
